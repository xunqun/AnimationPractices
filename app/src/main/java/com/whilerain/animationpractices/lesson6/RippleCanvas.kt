package com.whilerain.animationpractices.lesson6import android.content.Contextimport android.graphics.Canvasimport android.graphics.Colorimport android.graphics.Paintimport android.os.CountDownTimerimport android.util.AttributeSetimport android.view.Viewimport java.util.ArrayListclass RippleCanvas : View {    private val paint = Paint()    private var drawLeft: Int = 0    private var drawTop: Int = 0    private var drawWidth: Int = 0    private var drawHeight: Int = 0    private val ripples = ArrayList<RippleAnimator>()    constructor(context: Context) : super(context) {        initView()    }    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {        initView()    }    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {        initView()    }    private fun initView() {        paint.style = Paint.Style.STROKE        paint.color = Color.WHITE        paint.strokeWidth = 2f    }    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {        super.onLayout(changed, left, top, right, bottom)        drawLeft = 0 + paddingLeft        drawTop = 0 + paddingTop        drawWidth = right - left - paddingRight - paddingLeft        drawHeight = bottom - top - paddingTop - paddingBottom    }    override fun onDraw(canvas: Canvas) {        drawAllRipples(canvas)        super.onDraw(canvas)    }    fun createRipple() {        val r = RippleAnimator(4000)        ripples.add(r)        r.start()    }    private fun drawAllRipples(canvas: Canvas?) {        val iterator = ripples.iterator()        while (iterator.hasNext()) {            val r = iterator.next()            if (r.isFinished) {                iterator.remove()            } else {                if (canvas != null) r.draw(canvas)            }        }    }    internal inner class RippleAnimator(private val duration: Long) : CountDownTimer(duration, 30) {        private var ratio: Float? = 0f        private var tickCounter = 0        var isFinished = false        override fun onTick(millisUntilFinished: Long) {            tickCounter++            ratio = (duration.toFloat() - millisUntilFinished) / duration            invalidate()        }        override fun onFinish() {            isFinished = true        }        fun draw(canvas: Canvas) {            val x = drawWidth / 2 + drawLeft            val y = drawHeight / 2 + drawTop            val radius = drawWidth * ratio!!            paint.alpha = ((1 - ratio!!) * 255).toInt()            canvas.drawOval(x - radius, y - radius, x + radius, y + radius, paint)        }    }}